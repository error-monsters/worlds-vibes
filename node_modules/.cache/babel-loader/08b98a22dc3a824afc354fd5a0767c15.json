{"ast":null,"code":"import { Tween, Easing, update } from 'es6-tween';\nimport React, { useRef as useRef$1, useEffect as useEffect$1, useState, useReducer } from 'react';\nimport { useEventCallback } from 'react-cached-callback';\nimport { PerspectiveCamera, AmbientLight, PointLight, Color, Group, Mesh, TextureLoader, SphereGeometry, MeshBasicMaterial, BackSide, MeshLambertMaterial, BoxGeometry, Vector3, WebGLRenderer, Scene } from 'three';\nimport { Interaction } from 'three.interaction';\nimport OrbitControls from 'three-orbitcontrols';\nimport { createGlowMesh } from 'three-glow-mesh';\nimport { min, max } from 'd3-array';\nimport { scaleLinear } from 'd3-scale';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport tippy from 'tippy.js';\n\nfunction coordinatesToPosition(coordinates, radius) {\n  var lat = coordinates[0],\n      long = coordinates[1];\n  var phi = lat * Math.PI / 180;\n  var theta = (long - 180) * Math.PI / 180;\n  var x = -radius * Math.cos(phi) * Math.cos(theta);\n  var y = radius * Math.sin(phi);\n  var z = radius * Math.cos(phi) * Math.sin(theta);\n  return [x, y, z];\n}\n\nfunction tween( // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfrom, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nto, animationDuration, easingFunction, onUpdate, onEnd) {\n  new Tween(from).to(to, animationDuration).easing(Easing[easingFunction[0]][easingFunction[1]]).on('update', onUpdate).on('complete', onEnd).start();\n}\n\nvar MarkerType;\n\n(function (MarkerType) {\n  MarkerType[\"Bar\"] = \"bar\";\n  MarkerType[\"Dot\"] = \"dot\";\n})(MarkerType || (MarkerType = {})); // hardcoded constants that can eventually be exposed via options\n\n\nvar RADIUS = 300;\nvar BACKGROUND_RADIUS_SCALE = 10;\nvar CAMERA_FAR = RADIUS * 100;\nvar CAMERA_FOV = 45;\nvar CAMERA_NEAR = 1;\nvar CAMERA_DAMPING_FACTOR = 0.1;\nvar CAMERA_MAX_POLAR_ANGLE = Math.PI;\nvar CAMERA_MIN_POLAR_ANGLE = 0;\nvar CAMERA_MIN_DISTANCE_RADIUS_SCALE = 1.1;\nvar CLOUDS_RADIUS_OFFSET = 1;\nvar GLOBE_SEGMENTS = 50;\nvar MARKER_DEFAULT_COLOR = 'gold';\nvar MARKER_SEGMENTS = 10;\nvar MARKER_UNIT_RADIUS_SCALE = 0.01;\nvar MARKER_ACTIVE_ANIMATION_DURATION = 100;\nvar MARKER_ACTIVE_ANIMATION_EASING_FUNCTION = ['Cubic', 'In'];\nvar defaultCameraOptions = {\n  autoRotateSpeed: 0.02,\n  distanceRadiusScale: 3,\n  enableAutoRotate: true,\n  enableRotate: true,\n  enableZoom: true,\n  maxDistanceRadiusScale: 4,\n  maxPolarAngle: CAMERA_MAX_POLAR_ANGLE,\n  minPolarAngle: CAMERA_MIN_POLAR_ANGLE,\n  rotateSpeed: 0.02,\n  zoomSpeed: 1\n};\nvar defaultFocusOptions = {\n  animationDuration: 1000,\n  distanceRadiusScale: 1.5,\n  easingFunction: ['Cubic', 'Out'],\n  enableDefocus: true\n};\nvar defaultGlobeOptions = {\n  backgroundTexture: 'https://raw.githubusercontent.com/chrisrzhou/react-globe/master/textures/background.png',\n  cloudsSpeed: 0.5,\n  cloudsOpacity: 0.3,\n  cloudsTexture: 'https://raw.githubusercontent.com/chrisrzhou/react-globe/master/textures/clouds.png',\n  enableBackground: true,\n  enableClouds: true,\n  enableGlow: true,\n  glowCoefficient: 0.1,\n  glowColor: '#d1d1d1',\n  glowPower: 3,\n  glowRadiusScale: 0.2,\n  texture: 'https://raw.githubusercontent.com/chrisrzhou/react-globe/master/textures/globe.jpg'\n};\nvar defaultLightOptions = {\n  ambientLightColor: 'white',\n  ambientLightIntensity: 0.8,\n  pointLightColor: 'white',\n  pointLightIntensity: 1,\n  pointLightPositionRadiusScales: [-2, 1, -1]\n};\nvar defaultDotMarkerOptions = {\n  activeScale: 1.3,\n  animationDuration: 1000,\n  enableGlow: true,\n  enableTooltip: true,\n  getTooltipContent: function getTooltipContent(marker) {\n    return JSON.stringify(marker.coordinates);\n  },\n  glowCoefficient: 0,\n  glowPower: 3,\n  glowRadiusScale: 2,\n  radiusScaleRange: [0.005, 0.02],\n  type: MarkerType.Dot\n};\nvar defaultBarMarkerOptions = {\n  activeScale: 1.05,\n  animationDuration: 2000,\n  enableGlow: false,\n  enableTooltip: true,\n  getTooltipContent: function getTooltipContent(marker) {\n    return JSON.stringify(marker.coordinates);\n  },\n  glowCoefficient: 0,\n  glowPower: 3,\n  glowRadiusScale: 2,\n  offsetRadiusScale: 0,\n  radiusScaleRange: [0.2, defaultFocusOptions.distanceRadiusScale - 1],\n  type: MarkerType.Bar\n};\nvar defaultMarkerOptions = defaultDotMarkerOptions;\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nfunction useCamera(_a, _b, _c, rendererRef, size, lookAt, focus) {\n  var autoRotateSpeed = _a.autoRotateSpeed,\n      distanceRadiusScale = _a.distanceRadiusScale,\n      enableAutoRotate = _a.enableAutoRotate,\n      enableRotate = _a.enableRotate,\n      enableZoom = _a.enableZoom,\n      maxDistanceRadiusScale = _a.maxDistanceRadiusScale,\n      maxPolarAngle = _a.maxPolarAngle,\n      minPolarAngle = _a.minPolarAngle,\n      rotateSpeed = _a.rotateSpeed,\n      zoomSpeed = _a.zoomSpeed;\n  var ambientLightColor = _b.ambientLightColor,\n      ambientLightIntensity = _b.ambientLightIntensity,\n      pointLightColor = _b.pointLightColor,\n      pointLightIntensity = _b.pointLightIntensity,\n      pointLightPositionRadiusScales = _b.pointLightPositionRadiusScales;\n  var focusAnimationDuration = _c.animationDuration,\n      focusDistanceRadiusScale = _c.distanceRadiusScale,\n      focusEasingFunction = _c.easingFunction;\n  var cameraRef = useRef$1(new PerspectiveCamera());\n  var ambientLightRef = useRef$1();\n  var pointLightRef = useRef$1();\n  var orbitControlsRef = useRef$1();\n  var preFocusPositionRef = useRef$1();\n  var pointLightRadiusScaleX = pointLightPositionRadiusScales[0],\n      pointLightRadiusScaleY = pointLightPositionRadiusScales[1],\n      pointLightRadiusScaleZ = pointLightPositionRadiusScales[2]; // init\n\n  useEffect$1(function () {\n    var camera = cameraRef.current;\n    var ambientLight = new AmbientLight('white');\n    ambientLightRef.current = ambientLight;\n    camera.add(ambientLight);\n    var pointLight = new PointLight('white');\n    pointLightRef.current = pointLight;\n    camera.add(pointLight);\n    orbitControlsRef.current = new OrbitControls(camera, rendererRef.current.domElement);\n  }, [rendererRef]); // update options\n\n  useEffect$1(function () {\n    var _a;\n\n    var camera = cameraRef.current;\n    var orbitControls = orbitControlsRef.current;\n    var ambientLight = ambientLightRef.current;\n    var pointLight = pointLightRef.current;\n    camera.far = CAMERA_FAR;\n    camera.fov = CAMERA_FOV;\n    camera.near = CAMERA_NEAR;\n    var position = coordinatesToPosition(lookAt, RADIUS * distanceRadiusScale);\n\n    (_a = camera.position).set.apply(_a, position); // apply light options\n\n\n    ambientLight.color = new Color(ambientLightColor);\n    ambientLight.intensity = ambientLightIntensity;\n    pointLight.color = new Color(pointLightColor);\n    pointLight.intensity = pointLightIntensity;\n    pointLight.position.set(RADIUS * pointLightRadiusScaleX, RADIUS * pointLightRadiusScaleY, RADIUS * pointLightRadiusScaleZ); // apply orbit controls options\n\n    orbitControls.enableDamping = true;\n    orbitControls.autoRotate = enableAutoRotate;\n    orbitControls.autoRotateSpeed = autoRotateSpeed;\n    orbitControls.dampingFactor = CAMERA_DAMPING_FACTOR;\n    orbitControls.enablePan = false;\n    orbitControls.enableRotate = enableRotate;\n    orbitControls.enableZoom = enableZoom;\n    orbitControls.maxDistance = RADIUS * maxDistanceRadiusScale;\n    orbitControls.maxPolarAngle = maxPolarAngle;\n    orbitControls.minDistance = RADIUS * CAMERA_MIN_DISTANCE_RADIUS_SCALE;\n    orbitControls.minPolarAngle = minPolarAngle;\n    orbitControls.rotateSpeed = rotateSpeed;\n    orbitControls.zoomSpeed = zoomSpeed;\n    orbitControlsRef.current = orbitControls;\n  }, [ambientLightColor, ambientLightIntensity, autoRotateSpeed, distanceRadiusScale, enableAutoRotate, enableRotate, enableZoom, lookAt, maxDistanceRadiusScale, maxPolarAngle, minPolarAngle, pointLightColor, pointLightIntensity, pointLightRadiusScaleX, pointLightRadiusScaleY, pointLightRadiusScaleZ, rotateSpeed, zoomSpeed]); // update size\n\n  useEffect$1(function () {\n    var camera = cameraRef.current;\n    camera.aspect = size[0] / size[1];\n    camera.updateProjectionMatrix();\n  }, [size]); // update focus\n\n  useEffect$1(function () {\n    var orbitControls = orbitControlsRef.current;\n    var camera = cameraRef.current;\n    var preFocusPosition = preFocusPositionRef.current;\n\n    if (focus) {\n      // disable orbit controls when focused\n      orbitControls.autoRotate = false;\n      orbitControls.enabled = false;\n      orbitControls.minPolarAngle = CAMERA_MIN_POLAR_ANGLE;\n      orbitControls.maxPolarAngle = CAMERA_MAX_POLAR_ANGLE;\n      var from_1 = [camera.position.x, camera.position.y, camera.position.z];\n      var to = coordinatesToPosition(focus, RADIUS * focusDistanceRadiusScale);\n      preFocusPositionRef.current = preFocusPosition || from_1.slice();\n      tween(from_1, to, focusAnimationDuration, focusEasingFunction, function () {\n        var _a;\n\n        (_a = camera.position).set.apply(_a, from_1);\n      });\n    } else {\n      if (preFocusPosition) {\n        var from_2 = [camera.position.x, camera.position.y, camera.position.z];\n        var to = preFocusPosition;\n        tween(from_2, to, focusAnimationDuration, focusEasingFunction, function () {\n          var _a;\n\n          (_a = camera.position).set.apply(_a, from_2);\n        }, function () {\n          orbitControls.enabled = true;\n          orbitControls.autoRotate = enableAutoRotate;\n          orbitControls.maxPolarAngle = maxPolarAngle;\n          orbitControls.minPolarAngle = minPolarAngle;\n          preFocusPositionRef.current = undefined;\n        });\n      }\n    }\n  }, [enableAutoRotate, focus, focusAnimationDuration, focusDistanceRadiusScale, focusEasingFunction, maxPolarAngle, minPolarAngle]);\n  return [cameraRef, orbitControlsRef];\n}\n\nvar SECONDS_TO_MILLISECONDS = 1000;\n\nfunction useGlobe(_a, onTextureLoaded) {\n  var backgroundTexture = _a.backgroundTexture,\n      cloudsOpacity = _a.cloudsOpacity,\n      cloudsSpeed = _a.cloudsSpeed,\n      cloudsTexture = _a.cloudsTexture,\n      enableBackground = _a.enableBackground,\n      enableClouds = _a.enableClouds,\n      enableGlow = _a.enableGlow,\n      glowCoefficient = _a.glowCoefficient,\n      glowColor = _a.glowColor,\n      glowPower = _a.glowPower,\n      glowRadiusScale = _a.glowRadiusScale,\n      texture = _a.texture;\n  var globeRef = useRef$1(new Group());\n  var sphereRef = useRef$1(new Mesh());\n  var backgroundRef = useRef$1(new Mesh());\n  var cloudsRef = useRef$1(new Mesh()); // init\n\n  useEffect$1(function () {\n    var globe = globeRef.current;\n    var sphere = sphereRef.current;\n    var background = backgroundRef.current;\n    var clouds = cloudsRef.current;\n    var cloudsAnimationFrameID; // add background if enabled\n\n    if (enableBackground) {\n      new TextureLoader().load(backgroundTexture, function (map) {\n        background.geometry = new SphereGeometry(RADIUS * BACKGROUND_RADIUS_SCALE, GLOBE_SEGMENTS, GLOBE_SEGMENTS);\n        background.material = new MeshBasicMaterial({\n          map: map,\n          side: BackSide\n        });\n        globe.add(background);\n      });\n    } // add clouds if enabled\n\n\n    if (enableClouds) {\n      new TextureLoader().load(cloudsTexture, function (map) {\n        clouds.geometry = new SphereGeometry(RADIUS + CLOUDS_RADIUS_OFFSET, GLOBE_SEGMENTS, GLOBE_SEGMENTS);\n        clouds.material = new MeshLambertMaterial({\n          map: map,\n          transparent: true\n        });\n        clouds.material.opacity = cloudsOpacity;\n        globe.add(clouds);\n\n        function animateClouds() {\n          clouds.rotation.x += Math.random() * cloudsSpeed / SECONDS_TO_MILLISECONDS;\n          clouds.rotation.y += Math.random() * cloudsSpeed / SECONDS_TO_MILLISECONDS;\n          clouds.rotation.z += Math.random() * cloudsSpeed / SECONDS_TO_MILLISECONDS;\n          cloudsAnimationFrameID = requestAnimationFrame(animateClouds);\n        }\n\n        animateClouds();\n      });\n    }\n\n    new TextureLoader().load(texture, function (map) {\n      sphere.geometry = new SphereGeometry(RADIUS, GLOBE_SEGMENTS, GLOBE_SEGMENTS);\n      sphere.material = new MeshLambertMaterial({\n        map: map\n      });\n      globe.add(sphere); // add glow if enabled\n\n      if (enableGlow) {\n        var glowMesh = createGlowMesh(sphere.geometry, {\n          backside: true,\n          color: glowColor,\n          coefficient: glowCoefficient,\n          power: glowPower,\n          size: RADIUS * glowRadiusScale\n        });\n        sphere.children = []; // remove all glow instances\n\n        sphere.add(glowMesh);\n      }\n\n      onTextureLoaded && onTextureLoaded();\n    });\n    return function () {\n      if (enableClouds && cloudsAnimationFrameID) {\n        cancelAnimationFrame(cloudsAnimationFrameID);\n      }\n    };\n  }, [backgroundTexture, cloudsOpacity, cloudsSpeed, cloudsTexture, enableBackground, enableClouds, enableGlow, glowCoefficient, glowColor, glowPower, glowRadiusScale, onTextureLoaded, texture]);\n  return globeRef;\n}\n\nfunction useMarkers(markers, _a, _b) {\n  var animationDuration = _a.animationDuration,\n      enableGlow = _a.enableGlow,\n      glowCoefficient = _a.glowCoefficient,\n      glowPower = _a.glowPower,\n      glowRadiusScale = _a.glowRadiusScale,\n      offsetRadiusScale = _a.offsetRadiusScale,\n      radiusScaleRange = _a.radiusScaleRange,\n      renderer = _a.renderer,\n      type = _a.type;\n  var onClick = _b.onClick,\n      onMouseOver = _b.onMouseOver;\n  var markersRef = useRef$1(new Group());\n  var unitRadius = RADIUS * MARKER_UNIT_RADIUS_SCALE; // init\n\n  useEffect$1(function () {\n    var sizeScale = scaleLinear().domain([min(markers, function (marker) {\n      return marker.value;\n    }), max(markers, function (marker) {\n      return marker.value;\n    })]).range([RADIUS * radiusScaleRange[0], RADIUS * radiusScaleRange[1]]);\n    markersRef.current.children = []; // clear data before adding\n\n    markers.forEach(function (marker) {\n      var _a;\n\n      var coordinates = marker.coordinates,\n          value = marker.value;\n      var shouldUseCustomMarker = renderer !== undefined;\n      var color = marker.color || MARKER_DEFAULT_COLOR;\n      var size = sizeScale(value);\n      var markerObject;\n\n      if (shouldUseCustomMarker) {\n        markerObject = renderer(marker);\n      } else {\n        var from_1 = {\n          size: 0\n        };\n        var to = {\n          size: size\n        };\n        var mesh_1 = new Mesh();\n        tween(from_1, to, animationDuration, ['Linear', 'None'], function () {\n          switch (type) {\n            case MarkerType.Bar:\n              mesh_1.geometry = new BoxGeometry(unitRadius, unitRadius, from_1.size);\n              mesh_1.material = new MeshLambertMaterial({\n                color: color\n              });\n              break;\n\n            case MarkerType.Dot:\n            default:\n              mesh_1.geometry = new SphereGeometry(from_1.size, MARKER_SEGMENTS, MARKER_SEGMENTS);\n              mesh_1.material = new MeshBasicMaterial({\n                color: color\n              });\n\n              if (enableGlow) {\n                // add glow\n                var glowMesh = createGlowMesh(mesh_1.geometry.clone(), {\n                  backside: false,\n                  color: color,\n                  coefficient: glowCoefficient,\n                  power: glowPower,\n                  size: from_1.size * glowRadiusScale\n                });\n                mesh_1.children = [];\n                mesh_1.add(glowMesh);\n              }\n\n          }\n        });\n        markerObject = mesh_1;\n      } // place markers\n\n\n      var heightOffset = 0;\n\n      if (offsetRadiusScale !== undefined) {\n        heightOffset = RADIUS * offsetRadiusScale;\n      } else {\n        if (type === MarkerType.Dot) {\n          heightOffset = size * (1 + glowRadiusScale) / 2;\n        } else {\n          heightOffset = 0;\n        }\n      }\n\n      var position = coordinatesToPosition(coordinates, RADIUS + heightOffset);\n\n      (_a = markerObject.position).set.apply(_a, position);\n\n      markerObject.lookAt(new Vector3(0, 0, 0)); // handle events\n\n      function handleClick(event) {\n        event.stopPropagation();\n        onClick(marker, markerObject, event.data.originalEvent);\n      }\n\n      markerObject.on('click', handleClick);\n      markerObject.on('touchstart', handleClick);\n      markerObject.on('mousemove', function (event) {\n        event.stopPropagation();\n        onMouseOver(marker, markerObject, event.data.originalEvent);\n      });\n      markersRef.current.add(markerObject);\n    });\n  }, [animationDuration, enableGlow, glowCoefficient, glowPower, glowRadiusScale, markers, offsetRadiusScale, onClick, onMouseOver, radiusScaleRange, renderer, type, unitRadius]);\n  return markersRef;\n}\n\nfunction useRenderer(size) {\n  var rendererRef = useRef$1();\n  var canvasRef = useRef$1(); // init\n\n  useEffect$1(function () {\n    rendererRef.current = new WebGLRenderer({\n      alpha: true,\n      antialias: true,\n      canvas: canvasRef.current\n    });\n  }, []); // update size\n\n  useEffect$1(function () {\n    var _a;\n\n    (_a = rendererRef.current).setSize.apply(_a, size);\n  }, [size]);\n  return [rendererRef, canvasRef];\n}\n\nfunction useResize(initialSize) {\n  var mountRef = useRef$1();\n\n  var _a = useState([0, 0]),\n      size = _a[0],\n      setSize = _a[1];\n\n  useEffect$1(function () {\n    var mount = mountRef.current; // update initial size\n\n    var width = 0;\n    var height = 0;\n\n    if (initialSize) {\n      // Use initialSize if it is provided\n      width = initialSize[0], height = initialSize[1];\n    } else {\n      // Use parentElement size if resized has not updated\n      width = mount.offsetWidth;\n      height = mount.offsetHeight;\n    }\n\n    setSize([width, height]); // update resize using a resize observer\n\n    var resizeObserver = new ResizeObserver(function (entries) {\n      if (!entries || !entries.length) {\n        return;\n      }\n\n      if (initialSize === undefined) {\n        var _a = entries[0].contentRect,\n            width_1 = _a.width,\n            height_1 = _a.height;\n        setSize([width_1, height_1]);\n      }\n    });\n    resizeObserver.observe(mount);\n    return function () {\n      resizeObserver.unobserve(mount);\n    };\n  }, [initialSize]);\n  return [mountRef, size];\n}\n\nvar ActionType;\n\n(function (ActionType) {\n  ActionType[\"Animate\"] = \"ANIMATE\";\n  ActionType[\"SetFocus\"] = \"SET_FOCUS\";\n  ActionType[\"SetActiveMarker\"] = \"SET_ACTIVE_MANAGER\";\n})(ActionType || (ActionType = {}));\n\nfunction reducer(state, action) {\n  var payload = action.payload,\n      type = action.type;\n\n  switch (type) {\n    case ActionType.Animate:\n      return _assign({}, state, {\n        activeMarker: undefined,\n        activeMarkerObject: undefined,\n        focus: payload.focus,\n        focusOptions: payload.focusOptions\n      });\n\n    case ActionType.SetFocus:\n      return _assign({}, state, {\n        activeMarker: undefined,\n        activeMarkerObject: undefined,\n        focus: payload.focus,\n        focusOptions: payload.focusOptions || state.focusOptions\n      });\n\n    case ActionType.SetActiveMarker:\n      return _assign({}, state, {\n        activeMarker: payload.marker,\n        activeMarkerObject: payload.markerObject\n      });\n\n    default:\n      return state;\n  }\n}\n\nvar useEffect = React.useEffect,\n    useRef = React.useRef;\nvar tooltipInstance;\n\nfunction Tooltip(_a) {\n  var content = _a.content,\n      offset = _a.offset,\n      x = _a.x,\n      y = _a.y;\n  var ref = useRef();\n  useEffect(function () {\n    document.body.style.cursor = 'pointer';\n    tooltipInstance = tippy(ref.current, {\n      animation: 'scale',\n      content: content\n    });\n    tooltipInstance.show();\n    return function () {\n      document.body.style.cursor = 'inherit';\n\n      if (tooltipInstance) {\n        tooltipInstance.destroy();\n      }\n    };\n  }, [content]);\n  return React.createElement(\"div\", {\n    ref: ref,\n    style: {\n      left: x + offset,\n      position: 'fixed',\n      top: y + offset\n    }\n  });\n}\n\nfunction ReactGlobe(_a) {\n  var animations = _a.animations,\n      cameraOptions = _a.cameraOptions,\n      initialFocus = _a.focus,\n      initialFocusOptions = _a.focusOptions,\n      globeOptions = _a.globeOptions,\n      lightOptions = _a.lightOptions,\n      lookAt = _a.lookAt,\n      markers = _a.markers,\n      markerOptions = _a.markerOptions,\n      onClickMarker = _a.onClickMarker,\n      onDefocus = _a.onDefocus,\n      onMouseOutMarker = _a.onMouseOutMarker,\n      onMouseOverMarker = _a.onMouseOverMarker,\n      onTextureLoaded = _a.onTextureLoaded,\n      initialSize = _a.size; // merge options with defaults to support incomplete options\n\n  var mergedGlobeOptions = _assign({}, defaultGlobeOptions, globeOptions);\n\n  var mergedCameraOptions = _assign({}, defaultCameraOptions, cameraOptions);\n\n  var mergedLightOptions = _assign({}, defaultLightOptions, lightOptions);\n\n  var mergedFocusOptions = _assign({}, defaultFocusOptions, initialFocusOptions);\n\n  var mergedMarkerOptions = _assign({}, defaultMarkerOptions, markerOptions);\n\n  var _b = useReducer(reducer, {\n    focus: initialFocus,\n    focusOptions: mergedFocusOptions\n  }),\n      state = _b[0],\n      dispatch = _b[1];\n\n  var activeMarker = state.activeMarker,\n      activeMarkerObject = state.activeMarkerObject,\n      focus = state.focus,\n      focusOptions = state.focusOptions;\n  var enableDefocus = focusOptions.enableDefocus;\n  var activeScale = mergedMarkerOptions.activeScale,\n      enableTooltip = mergedMarkerOptions.enableTooltip,\n      getTooltipContent = mergedMarkerOptions.getTooltipContent; // cache event handlers\n\n  var handleClickMarker = useEventCallback(function (marker, markerObject, event) {\n    dispatch({\n      type: ActionType.SetFocus,\n      payload: {\n        focus: marker.coordinates\n      }\n    });\n    onClickMarker && onClickMarker(marker, markerObject, event);\n  });\n  var handleMouseOutMarker = useEventCallback(function (marker, markerObject, event) {\n    dispatch({\n      type: ActionType.SetActiveMarker,\n      payload: {\n        activeMarker: undefined,\n        activeMarkerObject: undefined\n      }\n    });\n    var from = [activeScale, activeScale, activeScale];\n    tween(from, [1, 1, 1], MARKER_ACTIVE_ANIMATION_DURATION, MARKER_ACTIVE_ANIMATION_EASING_FUNCTION, function () {\n      var _a;\n\n      if (activeMarkerObject) {\n        (_a = activeMarkerObject.scale).set.apply(_a, from);\n      }\n    });\n    onMouseOutMarker && onMouseOutMarker(marker, activeMarkerObject, event);\n  });\n  var handleMouseOverMarker = useEventCallback(function (marker, markerObject, event) {\n    dispatch({\n      type: ActionType.SetActiveMarker,\n      payload: {\n        marker: marker,\n        markerObject: markerObject\n      }\n    });\n    var from = markerObject.scale.toArray();\n    tween(from, [activeScale, activeScale, activeScale], MARKER_ACTIVE_ANIMATION_DURATION, MARKER_ACTIVE_ANIMATION_EASING_FUNCTION, function () {\n      var _a;\n\n      if (markerObject) {\n        (_a = markerObject.scale).set.apply(_a, from);\n      }\n    });\n    onMouseOverMarker && onMouseOverMarker(marker, markerObject, event);\n  });\n  var handleDefocus = useEventCallback(function (event) {\n    if (focus && enableDefocus) {\n      dispatch({\n        type: ActionType.SetFocus,\n        payload: {\n          focus: undefined\n        }\n      });\n      onDefocus && onDefocus(focus, event);\n    }\n  }); // initialize THREE instances\n\n  var _c = useResize(initialSize),\n      mountRef = _c[0],\n      size = _c[1];\n\n  var _d = useRenderer(size),\n      rendererRef = _d[0],\n      canvasRef = _d[1];\n\n  var globeRef = useGlobe(mergedGlobeOptions, onTextureLoaded);\n\n  var _e = useCamera(mergedCameraOptions, mergedLightOptions, focusOptions, rendererRef, size, lookAt, focus),\n      cameraRef = _e[0],\n      orbitControlsRef = _e[1];\n\n  var markersRef = useMarkers(markers, mergedMarkerOptions, {\n    onClick: handleClickMarker,\n    onMouseOver: handleMouseOverMarker\n  });\n  var mouseRef = useRef$1(); // track mouse position\n\n  useEffect$1(function () {\n    function onMouseUpdate(e) {\n      mouseRef.current = {\n        x: e.clientX,\n        y: e.clientY\n      };\n    }\n\n    document.addEventListener('mousemove', onMouseUpdate, false);\n    return function () {\n      document.removeEventListener('mousemove', onMouseUpdate, false);\n    };\n  }, []); // update state from props\n\n  useEffect$1(function () {\n    dispatch({\n      type: ActionType.SetFocus,\n      payload: {\n        focus: initialFocus,\n        focusOptions: _assign({}, defaultFocusOptions, initialFocusOptions)\n      }\n    });\n  }, [initialFocus, initialFocusOptions]); // handle animations\n\n  useEffect$1(function () {\n    var wait = 0;\n    var timeouts = [];\n    animations.forEach(function (animation) {\n      var animationDuration = animation.animationDuration,\n          coordinates = animation.coordinates,\n          distanceRadiusScale = animation.distanceRadiusScale,\n          easingFunction = animation.easingFunction;\n      var timeout = setTimeout(function () {\n        dispatch({\n          type: ActionType.Animate,\n          payload: {\n            focus: coordinates,\n            focusOptions: {\n              animationDuration: animationDuration,\n              distanceRadiusScale: distanceRadiusScale,\n              easingFunction: easingFunction\n            }\n          }\n        });\n      }, wait);\n      timeouts.push(timeout);\n      wait += animationDuration;\n    });\n    return function () {\n      timeouts.forEach(function (timeout) {\n        clearTimeout(timeout);\n      });\n    };\n  }, [animations]); // handle scene and rendering loop\n\n  useEffect$1(function () {\n    var mount = mountRef.current;\n    var renderer = rendererRef.current;\n    var globe = globeRef.current;\n    var camera = cameraRef.current;\n    var animationFrameID; // create scene\n\n    var scene = new Scene();\n    globe.add(markersRef.current);\n    scene.add(camera);\n    scene.add(globe);\n    mount.appendChild(renderer.domElement); // initialize interaction events\n\n    new Interaction(renderer, scene, camera);\n    scene.on('mousemove', function (event) {\n      if (activeMarker) {\n        handleMouseOutMarker(activeMarker, activeMarkerObject, event.data.originalEvent);\n      }\n    });\n\n    if (enableDefocus && focus) {\n      scene.on('click', function (event) {\n        handleDefocus(event.data.originalEvent);\n      });\n    }\n\n    function animate() {\n      renderer.render(scene, cameraRef.current);\n      update();\n      orbitControlsRef.current.update();\n      animationFrameID = requestAnimationFrame(animate);\n    }\n\n    animate();\n    return function () {\n      if (animationFrameID) {\n        cancelAnimationFrame(animationFrameID);\n      }\n\n      mount.removeChild(renderer.domElement);\n    };\n  }, [activeMarker, activeMarkerObject, cameraRef, enableDefocus, focus, globeRef, handleDefocus, handleMouseOutMarker, markersRef, mountRef, orbitControlsRef, rendererRef]);\n  return React.createElement(\"div\", {\n    ref: mountRef,\n    style: {\n      height: '100%',\n      width: '100%'\n    }\n  }, React.createElement(\"canvas\", {\n    ref: canvasRef,\n    style: {\n      display: 'block'\n    }\n  }), enableTooltip && activeMarker && React.createElement(Tooltip, {\n    offset: 10,\n    x: mouseRef.current.x,\n    y: mouseRef.current.y,\n    content: getTooltipContent(activeMarker)\n  }));\n}\n\nReactGlobe.defaultProps = {\n  animations: [],\n  cameraOptions: defaultCameraOptions,\n  focusOptions: defaultFocusOptions,\n  globeOptions: defaultGlobeOptions,\n  lightOptions: defaultLightOptions,\n  lookAt: [1.3521, 103.8198],\n  markers: [],\n  markerOptions: defaultMarkerOptions\n};\nexport default ReactGlobe;\nexport { BACKGROUND_RADIUS_SCALE, CAMERA_DAMPING_FACTOR, CAMERA_FAR, CAMERA_FOV, CAMERA_MAX_POLAR_ANGLE, CAMERA_MIN_DISTANCE_RADIUS_SCALE, CAMERA_MIN_POLAR_ANGLE, CAMERA_NEAR, CLOUDS_RADIUS_OFFSET, GLOBE_SEGMENTS, MARKER_ACTIVE_ANIMATION_DURATION, MARKER_ACTIVE_ANIMATION_EASING_FUNCTION, MARKER_DEFAULT_COLOR, MARKER_SEGMENTS, MARKER_UNIT_RADIUS_SCALE, RADIUS, coordinatesToPosition, defaultBarMarkerOptions, defaultCameraOptions, defaultDotMarkerOptions, defaultFocusOptions, defaultGlobeOptions, defaultLightOptions, defaultMarkerOptions, tween };","map":null,"metadata":{},"sourceType":"module"}